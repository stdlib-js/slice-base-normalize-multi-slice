{"version":3,"file":"index.mjs","sources":["../lib/main.js","../lib/error_out_of_bounds.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport MultiSlice from '@stdlib/slice-multi';\nimport Slice from '@stdlib/slice-ctor';\nimport normalizeSlice from '@stdlib/slice-base-normalize-slice';\nimport eOutOfBounds from './error_out_of_bounds.js';\n\n\n// FUNCTIONS //\n\n/**\n* Normalizes an individual MultiSlice element.\n*\n* @private\n* @param {(Slice|integer|null)} value - input slice\n* @param {NonNegativeInteger} len - maximum number of elements which are allowed in a slice\n* @param {boolean} strict - boolean indicating whether to enforce strict bounds checking\n* @returns {Slice} slice object\n*/\nfunction normalize( value, len, strict ) {\n\t// Case: null\n\tif ( value === null ) {\n\t\t// Create a slice with default extents and a default increment:\n\t\treturn new Slice( 0, len, 1 );\n\t}\n\t// Case: integer\n\tif ( typeof value === 'number' ) {\n\t\t// If a value exceeds the last possible index, create an \"empty\" slice...\n\t\tif ( value >= len ) {\n\t\t\tif ( strict ) {\n\t\t\t\treturn eOutOfBounds();\n\t\t\t}\n\t\t\treturn new Slice( len, len, 1 );\n\t\t}\n\t\t// Check whether we need to resolve a slice relative to the last possible index...\n\t\tif ( value < 0 ) {\n\t\t\tvalue = len + value;\n\n\t\t\t// If a value exceeds the first index, create an \"empty\" slice...\n\t\t\tif ( value < 0 ) {\n\t\t\t\tif ( strict ) {\n\t\t\t\t\treturn eOutOfBounds();\n\t\t\t\t}\n\t\t\t\treturn new Slice( 0, 0, 1 );\n\t\t\t}\n\t\t\treturn new Slice( value, value+1, 1 ); // e.g., Slice( 2, 3, 1 ), which is the slice equivalent of only selecting the second row\n\t\t}\n\t\t// 0 <= s < N\n\t\treturn new Slice( value, value+1, 1 );\n\t}\n\t// Case: slice\n\treturn normalizeSlice( value, len, strict );\n}\n\n\n// MAIN //\n\n/**\n* Returns a normalized MultiSlice object.\n*\n* @param {MultiSlice} slice - input slice\n* @param {NonNegativeIntegerArray} shape - maximum allowed slice shape\n* @param {boolean} strict - boolean indicating whether to enforce strict bounds checking\n* @returns {(MultiSlice|ErrorObject)} multi-slice object or an error object\n*\n* @example\n* import Slice from '@stdlib/slice-ctor';\n* import MultiSlice from '@stdlib/slice-multi';\n*\n* var shape = [ 10, 10, 10 ];\n*\n* var s1 = new MultiSlice( new Slice( 2, null, 2 ), null, -4 );\n* var s2 = normalizeMultiSlice( s1, shape, false );\n* // returns <MultiSlice>\n*\n* var d = s2.data;\n* // returns [ <Slice>, <Slice>, <Slice> ]\n*\n* var v = d[ 0 ];\n* // returns <Slice>\n*\n* var start = v.start;\n* // returns 2\n*\n* var stop = v.stop;\n* // returns 10\n*\n* var step = v.step;\n* // returns 2\n*\n* v = d[ 1 ];\n* // returns <Slice>\n*\n* start = v.start;\n* // returns 0\n*\n* stop = v.stop;\n* // returns 10\n*\n* step = v.step;\n* // returns 1\n*\n* v = d[ 2 ];\n* // returns <Slice>\n*\n* start = v.start;\n* // returns 6\n*\n* stop = v.stop;\n* // returns 7\n*\n* step = v.step;\n* // returns 1\n*/\nfunction normalizeMultiSlice( slice, shape, strict ) {\n\tvar data;\n\tvar args;\n\tvar s;\n\tvar i;\n\n\tdata = slice.data;\n\targs = [];\n\tfor ( i = 0; i < data.length; i++ ) {\n\t\ts = normalize( data[ i ], shape[ i ], strict );\n\t\tif ( s.code !== void 0 ) {\n\t\t\treturn s;\n\t\t}\n\t\targs.push( s );\n\t}\n\n\t// Return a normalized slice:\n\treturn MultiSlice.apply( null, args );\n}\n\n\n// EXPORTS //\n\nexport default normalizeMultiSlice;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2023 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns an error object for a slice which exceeds index bounds.\n*\n* @private\n* @returns {Object} error object\n*/\nfunction error() {\n\treturn {\n\t\t'code': 'ERR_SLICE_OUT_OF_BOUNDS'\n\t};\n}\n\n\n// EXPORTS //\n\nexport default error;\n"],"names":["normalize","value","len","strict","Slice","code","normalizeSlice","normalizeMultiSlice","slice","shape","data","args","s","i","length","push","MultiSlice","apply"],"mappings":";;kQAuCA,SAASA,EAAWC,EAAOC,EAAKC,GAE/B,OAAe,OAAVF,EAEG,IAAIG,EAAO,EAAGF,EAAK,GAGL,iBAAVD,EAENA,GAASC,EACRC,ECpBA,CACNE,KAAQ,2BDsBA,IAAID,EAAOF,EAAKA,EAAK,GAGxBD,EAAQ,IACZA,EAAQC,EAAMD,GAGD,EACPE,EC/BD,CACNE,KAAQ,2BDiCC,IAAID,EAAO,EAAG,EAAG,GAKnB,IAAIA,EAAOH,EAAOA,EAAM,EAAG,GAG5BK,EAAgBL,EAAOC,EAAKC,EACpC,CA8DA,SAASI,EAAqBC,EAAOC,EAAON,GAC3C,IAAIO,EACAC,EACAC,EACAC,EAIJ,IAFAH,EAAOF,EAAME,KACbC,EAAO,GACDE,EAAI,EAAGA,EAAIH,EAAKI,OAAQD,IAAM,CAEnC,QAAgB,KADhBD,EAAIZ,EAAWU,EAAMG,GAAKJ,EAAOI,GAAKV,IAC/BE,KACN,OAAOO,EAERD,EAAKI,KAAMH,EACX,CAGD,OAAOI,EAAWC,MAAO,KAAMN,EAChC"}